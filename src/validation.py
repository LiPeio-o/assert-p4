#!/usr/bin/env python2

from json import load as load_json
from os import path
from P4_to_C import run as p4_to_c

MAX_CMD_FILES = 3
P4PKTGEN_OUTFILE = 'test-cases.json'
ASSERTP4_JSON_FILE = 'json/stag.json'

def generate_commands(p4pktgen_outfile, max_files):
    '''
    Generates up to `max_files` commands.txt based on the test cases generated by
    p4pktgen (`p4pktgen_outfile`).
    Returns an array of tuples containing the paths to the generated commands.txt files 
    and the 'input_packets' as described in the p4pktgen test cases.

    Parameters
    ----------
    p4pktgen_outfile : string
        path to the output of p4pktgen containing the test cases (test-cases.json)

    max_files : integer
        number of commands.txt files to generate
    '''
    out = []

    with open(p4pktgen_outfile) as p4pktgen_out:
        test_cases = load_json(p4pktgen_out)
        count = 0
        for test_case in test_cases:
            if test_case['result'] == 'NO_PACKET_FOUND': continue

            count += 1
            if count > max_files: break

            result = test_case['result']
            cmd_file = 'commands{}-{}.txt'.format(count, result)
            with open(cmd_file, 'w') as f:
                for cmd in test_case['ss_cli_setup_cmds']:
                    f.write('{}\n'.format(cmd))
                f.close()

                out.append((cmd_file, test_case['input_packets']))
        p4pktgen_out.close()
    return out

def generate_c_models(p4_json, test_cases):
    '''
    Generates the C model of the P4 program with input packets set.
    Returns an array of paths to the generated C models.

    Parameters
    ----------
        p4_json : string
            path to the JSON representation of the P4 program. This representation can be
            obtained with the command `p4c-bm2-ss <program.p4> --toJSON <outfile.json>`

        test_cases : tuple array
            array of tuples containing the paths to the commands.txt files and the 
            'input_packets' as described in the p4pktgen test cases.
    '''
    p4_name = path.splitext(path.basename(p4_json))[0]
    c_models = []
    for test_case in test_cases:
        cmd_file, input_packets = test_case

        cmd_file_name = path.splitext(path.basename(cmd_file))[0]
        input_packet = input_packets[0]
        
        # generate C model
        model_name = '{}-{}.c'.format(p4_name, cmd_file_name)
        p4_to_c(p4_json, cmd_file, model_name)
        
        # read all lines from the initial C model
        lines = []
        with open(model_name, 'r+') as c_model:
            lines = c_model.readlines()
        
        # add include for 'memcpy'
        lines.insert(1, "#include<string.h> // [VALIDATION]\n")

        # lines to be inserted into 'ParserImpl'
        memset1 = '\tmemset(&hdr, 0, sizeof(headers));\n'
        memset2 = '\tmemset(&meta, 0, sizeof(metadata));\n'
        memset3 = '\tmemset(&standard_metadata, 0, sizeof(standard_metadata_t));\n'
        port = '\tstandard_metadata.ingress_port = {};\n'.format(
            input_packet['port']
        )
        packet_len = '\tstandard_metadata.packet_length = {};\n'.format(
            input_packet['packet_len_bytes']
        )
        # TODO: finish packet memcpy
        packet = '\t//memcpy(&hdr, "{}", {});\n'.format(
            input_packet['packet_hexstr'], input_packet['packet_len_bytes']
        )
        validation_lines = [memset1, memset2, memset3, port, packet_len, packet]


        # erase all contents of the file and rewrite it while adding the input packet
        with open(model_name, 'w') as c_model:
            inside_ParserImpl = False
            packet_inserted = False
            for line in lines:
                if not packet_inserted:
                    # comment out 'klee_make_symbolic' calls
                    if 'klee_make_symbolic' in line:
                        line = '// {}'.format(line)

                    # check if the current line is inside the 'ParserImpl' function
                    if 'void ParserImpl()' in line:
                        inside_ParserImpl = True

                    # write test packet information before 'start()' call
                    if inside_ParserImpl and 'start()' in line:
                        c_model.write('\t// [VALIDATION]\n')
                        for validation_line in validation_lines:
                            c_model.write(validation_line)
                        packet_inserted = True
                
                c_model.write(line)
            
            c_model.close()

        
        # save C model filename
        c_models.append(model_name)

    return c_models

def run():
    cmd_files = generate_commands(P4PKTGEN_OUTFILE, MAX_CMD_FILES)
    generate_c_models(ASSERTP4_JSON_FILE, cmd_files)

if __name__ == '__main__':
    run()